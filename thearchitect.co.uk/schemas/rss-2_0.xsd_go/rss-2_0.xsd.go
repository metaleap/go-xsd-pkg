//	Auto-generated by the "go-xsd" package located at:
//		github.com/metaleap/go-xsd
//	Comments on types and fields (if any) are from the XSD file located at:
//		thearchitect.co.uk/schemas/rss-2_0.xsd
package go_Rss20

//	XML Schema for RSS v2.0 feed files.
//	Project home: http://www.codeplex.com/rss2schema/
//	Based on the RSS 2.0 specification document at http://cyber.law.harvard.edu/rss/rss.html
//	Author: Jorgen Thelin
//	Revision: 16
//	Date: 01-Nov-2008
//	Feedback to: http://www.codeplex.com/rss2schema/WorkItem/List.aspx

import (
	xsdt "github.com/metaleap/go-xsd/types"
)

type XsdGoPkgHasAttr_Version_XsdtDecimal_20 struct {
	Version xsdt.Decimal `xml:"version,attr"`
}

//	Returns the fixed value for Version -- "2.0"
func (me XsdGoPkgHasAttr_Version_XsdtDecimal_20) VersionFixed() xsdt.Decimal {
	return xsdt.Decimal("2.0")
}

//	A string indicating the program used to generate the channel.
type XsdGoPkgHasElems_generatorchoicesequenceRssChannelschema_Generator_XsdtString_ struct {
	//	A string indicating the program used to generate the channel.
	Generators []xsdt.String `xml:"generator"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_generatorchoicesequenceRssChannelschema_Generator_XsdtString_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_generatorchoicesequenceRssChannelschema_Generator_XsdtString_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_generatorchoicesequenceRssChannelschema_Generator_XsdtString_ instance.
func (me *XsdGoPkgHasElems_generatorchoicesequenceRssChannelschema_Generator_XsdtString_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_generatorchoicesequenceRssChannelschema_Generator_XsdtString_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	A URL that points to the documentation for the format used in the RSS file. It's probably a pointer to this page. It's for people who might stumble across an RSS file on a Web server 25 years from now and wonder what it is.
type XsdGoPkgHasElems_docschoicesequenceRssChannelschema_Docs_XsdtAnyURI_ struct {
	//	A URL that points to the documentation for the format used in the RSS file. It's probably a pointer to this page. It's for people who might stumble across an RSS file on a Web server 25 years from now and wonder what it is.
	Docses []xsdt.AnyURI `xml:"docs"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_docschoicesequenceRssChannelschema_Docs_XsdtAnyURI_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_docschoicesequenceRssChannelschema_Docs_XsdtAnyURI_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_docschoicesequenceRssChannelschema_Docs_XsdtAnyURI_ instance.
func (me *XsdGoPkgHasElems_docschoicesequenceRssChannelschema_Docs_XsdtAnyURI_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_docschoicesequenceRssChannelschema_Docs_XsdtAnyURI_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	A hint for aggregators telling them which hours they can skip.
//	A time in GMT when aggregators should not request the channel data. The hour beginning at midnight is hour zero.
type TSkipHour xsdt.NonNegativeInteger

//	This convenience method just performs a simple type conversion to TSkipHour's alias type xsdt.NonNegativeInteger.
func (me TSkipHour) ToXsdtNonNegativeInteger() xsdt.NonNegativeInteger {
	return xsdt.NonNegativeInteger(me)
}

//	Returns a string representation of this TSkipHour's current non-string scalar value.
func (me TSkipHour) String() string { return xsdt.NonNegativeInteger(me).String() }

//	Since TSkipHour is a non-string scalar type (either boolean or numeric), sets the current value obtained from parsing the specified string.
func (me *TSkipHour) Set(s string) { (*xsdt.NonNegativeInteger)(me).Set(s) }

type XsdGoPkgHasElems_hoursequenceSkipHoursListschema_Hour_TSkipHour_ struct {
	Hours []TSkipHour `xml:"hour"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_hoursequenceSkipHoursListschema_Hour_TSkipHour_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_hoursequenceSkipHoursListschema_Hour_TSkipHour_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_hoursequenceSkipHoursListschema_Hour_TSkipHour_ instance.
func (me *XsdGoPkgHasElems_hoursequenceSkipHoursListschema_Hour_TSkipHour_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_hoursequenceSkipHoursListschema_Hour_TSkipHour_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TSkipHoursList struct {
	XsdGoPkgHasElems_hoursequenceSkipHoursListschema_Hour_TSkipHour_
}

//	If the WalkHandlers.TSkipHoursList function is not nil (ie. was set by outside code), calls it with this TSkipHoursList instance as the single argument. Then calls the Walk() method on 1/1 embed(s) and 0/0 field(s) belonging to this TSkipHoursList instance.
func (me *TSkipHoursList) Walk() (err error) {
	if fn := WalkHandlers.TSkipHoursList; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElems_hoursequenceSkipHoursListschema_Hour_TSkipHour_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_skipHourschoicesequenceRssChannelschema_SkipHours_TSkipHoursList_ struct {
	//	A hint for aggregators telling them which hours they can skip.
	SkipHourses []*TSkipHoursList `xml:"skipHours"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_skipHourschoicesequenceRssChannelschema_SkipHours_TSkipHoursList_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_skipHourschoicesequenceRssChannelschema_SkipHours_TSkipHoursList_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_skipHourschoicesequenceRssChannelschema_SkipHours_TSkipHoursList_ instance.
func (me *XsdGoPkgHasElems_skipHourschoicesequenceRssChannelschema_SkipHours_TSkipHoursList_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_skipHourschoicesequenceRssChannelschema_SkipHours_TSkipHoursList_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.SkipHourses {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Copyright notice for content in the channel.
type XsdGoPkgHasElems_copyrightchoicesequenceRssChannelschema_Copyright_XsdtString_ struct {
	//	Copyright notice for content in the channel.
	Copyrights []xsdt.String `xml:"copyright"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_copyrightchoicesequenceRssChannelschema_Copyright_XsdtString_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_copyrightchoicesequenceRssChannelschema_Copyright_XsdtString_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_copyrightchoicesequenceRssChannelschema_Copyright_XsdtString_ instance.
func (me *XsdGoPkgHasElems_copyrightchoicesequenceRssChannelschema_Copyright_XsdtString_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_copyrightchoicesequenceRssChannelschema_Copyright_XsdtString_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	The language the channel is written in. This allows aggregators to group all Italian language sites, for example, on a single page. A list of allowable values for this element, as provided by Netscape, is here. You may also use values defined by the W3C.
type XsdGoPkgHasElems_languagechoicesequenceRssChannelschema_Language_XsdtLanguage_ struct {
	//	The language the channel is written in. This allows aggregators to group all Italian language sites, for example, on a single page. A list of allowable values for this element, as provided by Netscape, is here. You may also use values defined by the W3C.
	Languages []xsdt.Language `xml:"language"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_languagechoicesequenceRssChannelschema_Language_XsdtLanguage_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_languagechoicesequenceRssChannelschema_Language_XsdtLanguage_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_languagechoicesequenceRssChannelschema_Language_XsdtLanguage_ instance.
func (me *XsdGoPkgHasElems_languagechoicesequenceRssChannelschema_Language_XsdtLanguage_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_languagechoicesequenceRssChannelschema_Language_XsdtLanguage_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	The name of the channel. It's how people refer to your service. If you have an HTML website that contains the same information as your RSS file, the title of your channel should be the same as the title of your website.
type XsdGoPkgHasElems_titlechoicesequenceRssChannelschema_Title_XsdtString_ struct {
	//	The name of the channel. It's how people refer to your service. If you have an HTML website that contains the same information as your RSS file, the title of your channel should be the same as the title of your website.
	Titles []xsdt.String `xml:"title"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_titlechoicesequenceRssChannelschema_Title_XsdtString_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_titlechoicesequenceRssChannelschema_Title_XsdtString_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_titlechoicesequenceRssChannelschema_Title_XsdtString_ instance.
func (me *XsdGoPkgHasElems_titlechoicesequenceRssChannelschema_Title_XsdtString_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_titlechoicesequenceRssChannelschema_Title_XsdtString_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	The URL to the HTML website corresponding to the channel.
type XsdGoPkgHasElems_linkchoicesequenceRssChannelschema_Link_XsdtAnyURI_ struct {
	//	The URL to the HTML website corresponding to the channel.
	Links []xsdt.AnyURI `xml:"link"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_linkchoicesequenceRssChannelschema_Link_XsdtAnyURI_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_linkchoicesequenceRssChannelschema_Link_XsdtAnyURI_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_linkchoicesequenceRssChannelschema_Link_XsdtAnyURI_ instance.
func (me *XsdGoPkgHasElems_linkchoicesequenceRssChannelschema_Link_XsdtAnyURI_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_linkchoicesequenceRssChannelschema_Link_XsdtAnyURI_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	A hint for aggregators telling them which days they can skip.
//	A time in GMT, when aggregators should not request the channel data. The hour beginning at midnight is hour zero.
//	A day when aggregators should not request the channel data.
type TSkipDay xsdt.String

//	Returns true if the value of this enumerated TSkipDay is "Monday".
func (me TSkipDay) IsMonday() bool { return me == "Monday" }

//	Returns true if the value of this enumerated TSkipDay is "Tuesday".
func (me TSkipDay) IsTuesday() bool { return me == "Tuesday" }

//	This convenience method just performs a simple type conversion to TSkipDay's alias type xsdt.String.
func (me TSkipDay) ToXsdtString() xsdt.String { return xsdt.String(me) }

//	Returns true if the value of this enumerated TSkipDay is "Thursday".
func (me TSkipDay) IsThursday() bool { return me == "Thursday" }

//	Returns true if the value of this enumerated TSkipDay is "Wednesday".
func (me TSkipDay) IsWednesday() bool { return me == "Wednesday" }

//	Returns true if the value of this enumerated TSkipDay is "Friday".
func (me TSkipDay) IsFriday() bool { return me == "Friday" }

//	Returns true if the value of this enumerated TSkipDay is "Saturday".
func (me TSkipDay) IsSaturday() bool { return me == "Saturday" }

//	Returns true if the value of this enumerated TSkipDay is "Sunday".
func (me TSkipDay) IsSunday() bool { return me == "Sunday" }

//	Since TSkipDay is just a simple String type, this merely sets the current value from the specified string.
func (me *TSkipDay) Set(s string) { (*xsdt.String)(me).Set(s) }

//	Since TSkipDay is just a simple String type, this merely returns the current string value.
func (me TSkipDay) String() string { return xsdt.String(me).String() }

type XsdGoPkgHasElems_daysequenceSkipDaysListschema_Day_TSkipDay_ struct {
	//	A time in GMT, when aggregators should not request the channel data. The hour beginning at midnight is hour zero.
	Days []TSkipDay `xml:"day"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_daysequenceSkipDaysListschema_Day_TSkipDay_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_daysequenceSkipDaysListschema_Day_TSkipDay_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_daysequenceSkipDaysListschema_Day_TSkipDay_ instance.
func (me *XsdGoPkgHasElems_daysequenceSkipDaysListschema_Day_TSkipDay_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_daysequenceSkipDaysListschema_Day_TSkipDay_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TSkipDaysList struct {
	//	A time in GMT, when aggregators should not request the channel data. The hour beginning at midnight is hour zero.
	XsdGoPkgHasElems_daysequenceSkipDaysListschema_Day_TSkipDay_
}

//	If the WalkHandlers.TSkipDaysList function is not nil (ie. was set by outside code), calls it with this TSkipDaysList instance as the single argument. Then calls the Walk() method on 1/1 embed(s) and 0/0 field(s) belonging to this TSkipDaysList instance.
func (me *TSkipDaysList) Walk() (err error) {
	if fn := WalkHandlers.TSkipDaysList; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElems_daysequenceSkipDaysListschema_Day_TSkipDay_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_skipDayschoicesequenceRssChannelschema_SkipDays_TSkipDaysList_ struct {
	//	A hint for aggregators telling them which days they can skip.
	SkipDayses []*TSkipDaysList `xml:"skipDays"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_skipDayschoicesequenceRssChannelschema_SkipDays_TSkipDaysList_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_skipDayschoicesequenceRssChannelschema_SkipDays_TSkipDaysList_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_skipDayschoicesequenceRssChannelschema_SkipDays_TSkipDaysList_ instance.
func (me *XsdGoPkgHasElems_skipDayschoicesequenceRssChannelschema_SkipDays_TSkipDaysList_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_skipDayschoicesequenceRssChannelschema_SkipDays_TSkipDaysList_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.SkipDayses {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Email address for person responsible for technical issues relating to channel.
//	Using the regexp definiton of E-Mail Address by Lucadean from the .NET RegExp Pattern Repository at http://www.3leaf.com/default/NetRegExpRepository.aspx
type TEmailAddress xsdt.String

//	Since TEmailAddress is just a simple String type, this merely sets the current value from the specified string.
func (me *TEmailAddress) Set(s string) { (*xsdt.String)(me).Set(s) }

//	This convenience method just performs a simple type conversion to TEmailAddress's alias type xsdt.String.
func (me TEmailAddress) ToXsdtString() xsdt.String { return xsdt.String(me) }

//	Since TEmailAddress is just a simple String type, this merely returns the current string value.
func (me TEmailAddress) String() string { return xsdt.String(me).String() }

type XsdGoPkgHasElems_webMasterchoicesequenceRssChannelschema_WebMaster_TEmailAddress_ struct {
	//	Email address for person responsible for technical issues relating to channel.
	WebMasters []TEmailAddress `xml:"webMaster"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_webMasterchoicesequenceRssChannelschema_WebMaster_TEmailAddress_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_webMasterchoicesequenceRssChannelschema_WebMaster_TEmailAddress_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_webMasterchoicesequenceRssChannelschema_WebMaster_TEmailAddress_ instance.
func (me *XsdGoPkgHasElems_webMasterchoicesequenceRssChannelschema_WebMaster_TEmailAddress_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_webMasterchoicesequenceRssChannelschema_WebMaster_TEmailAddress_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	An item may represent a "story" -- much like a story in a newspaper or magazine; if so its description is a synopsis of the story, and the link points to the full story. An item may also be complete in itself, if so, the description contains the text (entity-encoded HTML is allowed), and the link and title may be omitted.
//	URL of a page for comments relating to the item.
type XsdGoPkgHasElems_commentschoicesequenceRssItemschema_Comments_XsdtAnyURI_ struct {
	//	URL of a page for comments relating to the item.
	Commentses []xsdt.AnyURI `xml:"comments"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_commentschoicesequenceRssItemschema_Comments_XsdtAnyURI_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_commentschoicesequenceRssItemschema_Comments_XsdtAnyURI_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_commentschoicesequenceRssItemschema_Comments_XsdtAnyURI_ instance.
func (me *XsdGoPkgHasElems_commentschoicesequenceRssItemschema_Comments_XsdtAnyURI_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_commentschoicesequenceRssItemschema_Comments_XsdtAnyURI_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Indicates when the item was published.
//	A date-time displayed in RFC-822 format.
//	Using the regexp definiton of rfc-822 date by Sam Ruby at http://www.intertwingly.net/blog/1360.html
type TRfc822FormatDate xsdt.String

//	Since TRfc822FormatDate is just a simple String type, this merely sets the current value from the specified string.
func (me *TRfc822FormatDate) Set(s string) { (*xsdt.String)(me).Set(s) }

//	Since TRfc822FormatDate is just a simple String type, this merely returns the current string value.
func (me TRfc822FormatDate) String() string { return xsdt.String(me).String() }

//	This convenience method just performs a simple type conversion to TRfc822FormatDate's alias type xsdt.String.
func (me TRfc822FormatDate) ToXsdtString() xsdt.String { return xsdt.String(me) }

type XsdGoPkgHasElems_pubDatechoicesequenceRssItemschema_PubDate_TRfc822FormatDate_ struct {
	//	Indicates when the item was published.
	PubDates []TRfc822FormatDate `xml:"pubDate"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_pubDatechoicesequenceRssItemschema_PubDate_TRfc822FormatDate_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_pubDatechoicesequenceRssItemschema_PubDate_TRfc822FormatDate_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_pubDatechoicesequenceRssItemschema_PubDate_TRfc822FormatDate_ instance.
func (me *XsdGoPkgHasElems_pubDatechoicesequenceRssItemschema_PubDate_TRfc822FormatDate_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_pubDatechoicesequenceRssItemschema_PubDate_TRfc822FormatDate_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Describes a media object that is attached to the item.
type XsdGoPkgHasAttr_Url_XsdtAnyURI_ struct {
	Url xsdt.AnyURI `xml:"url,attr"`
}

//	Size in bytes
type XsdGoPkgHasAttr_Length_XsdtNonNegativeInteger_ struct {
	//	Size in bytes
	Length xsdt.NonNegativeInteger `xml:"length,attr"`
}

//	MIME media-type of the enclosure
type XsdGoPkgHasAttr_Type_XsdtString_ struct {
	//	MIME media-type of the enclosure
	Type xsdt.String `xml:"type,attr"`
}

type TEnclosure struct {
	XsdGoPkgValue xsdt.String `xml:",chardata"`

	//	MIME media-type of the enclosure
	XsdGoPkgHasAttr_Type_XsdtString_

	//	URL where the enclosure is located
	XsdGoPkgHasAttr_Url_XsdtAnyURI_

	//	Size in bytes
	XsdGoPkgHasAttr_Length_XsdtNonNegativeInteger_
}

//	If the WalkHandlers.TEnclosure function is not nil (ie. was set by outside code), calls it with this TEnclosure instance as the single argument. Then calls the Walk() method on 0/3 embed(s) and 0/1 field(s) belonging to this TEnclosure instance.
func (me *TEnclosure) Walk() (err error) {
	if fn := WalkHandlers.TEnclosure; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Simply returns the value of its XsdGoPkgValue field.
func (me *TEnclosure) ToXsdtString() xsdt.String { return me.XsdGoPkgValue }

type XsdGoPkgHasElems_enclosurechoicesequenceRssItemschema_Enclosure_TEnclosure_ struct {
	//	Describes a media object that is attached to the item.
	Enclosures []*TEnclosure `xml:"enclosure"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_enclosurechoicesequenceRssItemschema_Enclosure_TEnclosure_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_enclosurechoicesequenceRssItemschema_Enclosure_TEnclosure_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_enclosurechoicesequenceRssItemschema_Enclosure_TEnclosure_ instance.
func (me *XsdGoPkgHasElems_enclosurechoicesequenceRssItemschema_Enclosure_TEnclosure_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_enclosurechoicesequenceRssItemschema_Enclosure_TEnclosure_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Enclosures {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	The item synopsis.
type XsdGoPkgHasElems_descriptionchoicesequenceRssItemschema_Description_XsdtString_ struct {
	//	The item synopsis.
	Descriptions []xsdt.String `xml:"description"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_descriptionchoicesequenceRssItemschema_Description_XsdtString_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_descriptionchoicesequenceRssItemschema_Description_XsdtString_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_descriptionchoicesequenceRssItemschema_Description_XsdtString_ instance.
func (me *XsdGoPkgHasElems_descriptionchoicesequenceRssItemschema_Description_XsdtString_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_descriptionchoicesequenceRssItemschema_Description_XsdtString_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Includes the item in one or more categories.
type XsdGoPkgHasAttr_Domain_XsdtString_ struct {
	Domain xsdt.String `xml:"domain,attr"`
}

type TCategory struct {
	XsdGoPkgValue xsdt.String `xml:",chardata"`

	XsdGoPkgHasAttr_Domain_XsdtString_
}

//	Simply returns the value of its XsdGoPkgValue field.
func (me *TCategory) ToXsdtString() xsdt.String { return me.XsdGoPkgValue }

//	If the WalkHandlers.TCategory function is not nil (ie. was set by outside code), calls it with this TCategory instance as the single argument. Then calls the Walk() method on 0/1 embed(s) and 0/1 field(s) belonging to this TCategory instance.
func (me *TCategory) Walk() (err error) {
	if fn := WalkHandlers.TCategory; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_categorychoicesequenceRssItemschema_Category_TCategory_ struct {
	//	Includes the item in one or more categories.
	Categories []*TCategory `xml:"category"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_categorychoicesequenceRssItemschema_Category_TCategory_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_categorychoicesequenceRssItemschema_Category_TCategory_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_categorychoicesequenceRssItemschema_Category_TCategory_ instance.
func (me *XsdGoPkgHasElems_categorychoicesequenceRssItemschema_Category_TCategory_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_categorychoicesequenceRssItemschema_Category_TCategory_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Categories {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	guid or permalink URL for this entry
type XsdGoPkgHasAttr_IsPermaLink_XsdtBoolean_True struct {
	IsPermaLink xsdt.Boolean `xml:"isPermaLink,attr"`
}

//	Returns the default value for IsPermaLink -- true
func (me XsdGoPkgHasAttr_IsPermaLink_XsdtBoolean_True) IsPermaLinkDefault() xsdt.Boolean {
	return xsdt.Boolean(true)
}

type TGuid struct {
	XsdGoPkgValue xsdt.String `xml:",chardata"`

	XsdGoPkgHasAttr_IsPermaLink_XsdtBoolean_True
}

//	If the WalkHandlers.TGuid function is not nil (ie. was set by outside code), calls it with this TGuid instance as the single argument. Then calls the Walk() method on 0/1 embed(s) and 0/1 field(s) belonging to this TGuid instance.
func (me *TGuid) Walk() (err error) {
	if fn := WalkHandlers.TGuid; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Simply returns the value of its XsdGoPkgValue field.
func (me *TGuid) ToXsdtString() xsdt.String { return me.XsdGoPkgValue }

type XsdGoPkgHasElems_guidchoicesequenceRssItemschema_Guid_TGuid_ struct {
	//	guid or permalink URL for this entry
	Guids []*TGuid `xml:"guid"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_guidchoicesequenceRssItemschema_Guid_TGuid_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_guidchoicesequenceRssItemschema_Guid_TGuid_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_guidchoicesequenceRssItemschema_Guid_TGuid_ instance.
func (me *XsdGoPkgHasElems_guidchoicesequenceRssItemschema_Guid_TGuid_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_guidchoicesequenceRssItemschema_Guid_TGuid_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Guids {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Email address of the author of the item.
type XsdGoPkgHasElems_authorchoicesequenceRssItemschema_Author_TEmailAddress_ struct {
	//	Email address of the author of the item.
	Authors []TEmailAddress `xml:"author"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_authorchoicesequenceRssItemschema_Author_TEmailAddress_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_authorchoicesequenceRssItemschema_Author_TEmailAddress_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_authorchoicesequenceRssItemschema_Author_TEmailAddress_ instance.
func (me *XsdGoPkgHasElems_authorchoicesequenceRssItemschema_Author_TEmailAddress_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_authorchoicesequenceRssItemschema_Author_TEmailAddress_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	The RSS channel that the item came from.
type TSource struct {
	XsdGoPkgValue xsdt.String `xml:",chardata"`

	XsdGoPkgHasAttr_Url_XsdtAnyURI_
}

//	Simply returns the value of its XsdGoPkgValue field.
func (me *TSource) ToXsdtString() xsdt.String { return me.XsdGoPkgValue }

//	If the WalkHandlers.TSource function is not nil (ie. was set by outside code), calls it with this TSource instance as the single argument. Then calls the Walk() method on 0/1 embed(s) and 0/1 field(s) belonging to this TSource instance.
func (me *TSource) Walk() (err error) {
	if fn := WalkHandlers.TSource; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_sourcechoicesequenceRssItemschema_Source_TSource_ struct {
	//	The RSS channel that the item came from.
	Sources []*TSource `xml:"source"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_sourcechoicesequenceRssItemschema_Source_TSource_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_sourcechoicesequenceRssItemschema_Source_TSource_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_sourcechoicesequenceRssItemschema_Source_TSource_ instance.
func (me *XsdGoPkgHasElems_sourcechoicesequenceRssItemschema_Source_TSource_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_sourcechoicesequenceRssItemschema_Source_TSource_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Sources {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TRssItem struct {
	//	The RSS channel that the item came from.
	XsdGoPkgHasElems_sourcechoicesequenceRssItemschema_Source_TSource_

	//	URL of a page for comments relating to the item.
	XsdGoPkgHasElems_commentschoicesequenceRssItemschema_Comments_XsdtAnyURI_

	//	The URL of the item.
	XsdGoPkgHasElems_linkchoicesequenceRssChannelschema_Link_XsdtAnyURI_

	//	Indicates when the item was published.
	XsdGoPkgHasElems_pubDatechoicesequenceRssItemschema_PubDate_TRfc822FormatDate_

	//	Describes a media object that is attached to the item.
	XsdGoPkgHasElems_enclosurechoicesequenceRssItemschema_Enclosure_TEnclosure_

	//	The item synopsis.
	XsdGoPkgHasElems_descriptionchoicesequenceRssItemschema_Description_XsdtString_

	//	Includes the item in one or more categories.
	XsdGoPkgHasElems_categorychoicesequenceRssItemschema_Category_TCategory_

	//	The title of the item.
	XsdGoPkgHasElems_titlechoicesequenceRssChannelschema_Title_XsdtString_

	//	guid or permalink URL for this entry
	XsdGoPkgHasElems_guidchoicesequenceRssItemschema_Guid_TGuid_

	//	Email address of the author of the item.
	XsdGoPkgHasElems_authorchoicesequenceRssItemschema_Author_TEmailAddress_
}

//	If the WalkHandlers.TRssItem function is not nil (ie. was set by outside code), calls it with this TRssItem instance as the single argument. Then calls the Walk() method on 10/10 embed(s) and 0/0 field(s) belonging to this TRssItem instance.
func (me *TRssItem) Walk() (err error) {
	if fn := WalkHandlers.TRssItem; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElems_sourcechoicesequenceRssItemschema_Source_TSource_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_commentschoicesequenceRssItemschema_Comments_XsdtAnyURI_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_linkchoicesequenceRssChannelschema_Link_XsdtAnyURI_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_pubDatechoicesequenceRssItemschema_PubDate_TRfc822FormatDate_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_enclosurechoicesequenceRssItemschema_Enclosure_TEnclosure_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_descriptionchoicesequenceRssItemschema_Description_XsdtString_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_categorychoicesequenceRssItemschema_Category_TCategory_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_titlechoicesequenceRssChannelschema_Title_XsdtString_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_guidchoicesequenceRssItemschema_Guid_TGuid_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_authorchoicesequenceRssItemschema_Author_TEmailAddress_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_itemsequenceRssChannelschema_Item_TRssItem_ struct {
	Items []*TRssItem `xml:"item"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_itemsequenceRssChannelschema_Item_TRssItem_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_itemsequenceRssChannelschema_Item_TRssItem_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_itemsequenceRssChannelschema_Item_TRssItem_ instance.
func (me *XsdGoPkgHasElems_itemsequenceRssChannelschema_Item_TRssItem_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_itemsequenceRssChannelschema_Item_TRssItem_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Items {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	The last time the content of the channel changed.
type XsdGoPkgHasElems_lastBuildDatechoicesequenceRssChannelschema_LastBuildDate_TRfc822FormatDate_ struct {
	//	The last time the content of the channel changed.
	LastBuildDates []TRfc822FormatDate `xml:"lastBuildDate"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_lastBuildDatechoicesequenceRssChannelschema_LastBuildDate_TRfc822FormatDate_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_lastBuildDatechoicesequenceRssChannelschema_LastBuildDate_TRfc822FormatDate_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_lastBuildDatechoicesequenceRssChannelschema_LastBuildDate_TRfc822FormatDate_ instance.
func (me *XsdGoPkgHasElems_lastBuildDatechoicesequenceRssChannelschema_LastBuildDate_TRfc822FormatDate_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_lastBuildDatechoicesequenceRssChannelschema_LastBuildDate_TRfc822FormatDate_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	ttl stands for time to live. It's a number of minutes that indicates how long a channel can be cached before refreshing from the source.
type XsdGoPkgHasElems_ttlchoicesequenceRssChannelschema_Ttl_XsdtNonNegativeInteger_ struct {
	//	ttl stands for time to live. It's a number of minutes that indicates how long a channel can be cached before refreshing from the source.
	Ttls []*xsdt.NonNegativeInteger `xml:"ttl"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_ttlchoicesequenceRssChannelschema_Ttl_XsdtNonNegativeInteger_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_ttlchoicesequenceRssChannelschema_Ttl_XsdtNonNegativeInteger_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_ttlchoicesequenceRssChannelschema_Ttl_XsdtNonNegativeInteger_ instance.
func (me *XsdGoPkgHasElems_ttlchoicesequenceRssChannelschema_Ttl_XsdtNonNegativeInteger_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_ttlchoicesequenceRssChannelschema_Ttl_XsdtNonNegativeInteger_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Specifies a GIF, JPEG or PNG image that can be displayed with the channel.
//	The URL of the site, when the channel is rendered, the image is a link to the site. (Note, in practice the image <title> and <link> should have the same value as the channel's <title> and <link>.
type XsdGoPkgHasElem_linkallImageschema_Link_XsdtAnyURI_ struct {
	//	The URL of the site, when the channel is rendered, the image is a link to the site. (Note, in practice the image <title> and <link> should have the same value as the channel's <title> and <link>.
	Link xsdt.AnyURI `xml:"link"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_linkallImageschema_Link_XsdtAnyURI_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_linkallImageschema_Link_XsdtAnyURI_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElem_linkallImageschema_Link_XsdtAnyURI_ instance.
func (me *XsdGoPkgHasElem_linkallImageschema_Link_XsdtAnyURI_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_linkallImageschema_Link_XsdtAnyURI_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	The width of the image in pixels.
//	The width of the image in pixels.
type TImageWidth xsdt.PositiveInteger

//	Returns a string representation of this TImageWidth's current non-string scalar value.
func (me TImageWidth) String() string { return xsdt.PositiveInteger(me).String() }

//	Since TImageWidth is a non-string scalar type (either boolean or numeric), sets the current value obtained from parsing the specified string.
func (me *TImageWidth) Set(s string) { (*xsdt.PositiveInteger)(me).Set(s) }

//	This convenience method just performs a simple type conversion to TImageWidth's alias type xsdt.PositiveInteger.
func (me TImageWidth) ToXsdtPositiveInteger() xsdt.PositiveInteger { return xsdt.PositiveInteger(me) }

type XsdGoPkgHasElem_widthallImageschema_Width_TImageWidth_88 struct {
	//	The width of the image in pixels.
	Width TImageWidth `xml:"width"`
}

//	Returns the default value for Width -- 88
func (me XsdGoPkgHasElem_widthallImageschema_Width_TImageWidth_88) WidthDefault() TImageWidth {
	return TImageWidth(88)
}

//	If the WalkHandlers.XsdGoPkgHasElem_widthallImageschema_Width_TImageWidth_88 function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_widthallImageschema_Width_TImageWidth_88 instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElem_widthallImageschema_Width_TImageWidth_88 instance.
func (me *XsdGoPkgHasElem_widthallImageschema_Width_TImageWidth_88) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_widthallImageschema_Width_TImageWidth_88; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	The URL of the image file.
type XsdGoPkgHasElem_urlallImageschema_Url_XsdtAnyURI_ struct {
	//	The URL of the image file.
	Url xsdt.AnyURI `xml:"url"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_urlallImageschema_Url_XsdtAnyURI_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_urlallImageschema_Url_XsdtAnyURI_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElem_urlallImageschema_Url_XsdtAnyURI_ instance.
func (me *XsdGoPkgHasElem_urlallImageschema_Url_XsdtAnyURI_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_urlallImageschema_Url_XsdtAnyURI_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	The height of the image in pixels.
//	The height of the image in pixels.
type TImageHeight xsdt.PositiveInteger

//	Returns a string representation of this TImageHeight's current non-string scalar value.
func (me TImageHeight) String() string { return xsdt.PositiveInteger(me).String() }

//	This convenience method just performs a simple type conversion to TImageHeight's alias type xsdt.PositiveInteger.
func (me TImageHeight) ToXsdtPositiveInteger() xsdt.PositiveInteger { return xsdt.PositiveInteger(me) }

//	Since TImageHeight is a non-string scalar type (either boolean or numeric), sets the current value obtained from parsing the specified string.
func (me *TImageHeight) Set(s string) { (*xsdt.PositiveInteger)(me).Set(s) }

type XsdGoPkgHasElem_heightallImageschema_Height_TImageHeight_31 struct {
	//	The height of the image in pixels.
	Height TImageHeight `xml:"height"`
}

//	Returns the default value for Height -- 31
func (me XsdGoPkgHasElem_heightallImageschema_Height_TImageHeight_31) HeightDefault() TImageHeight {
	return TImageHeight(31)
}

//	If the WalkHandlers.XsdGoPkgHasElem_heightallImageschema_Height_TImageHeight_31 function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_heightallImageschema_Height_TImageHeight_31 instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElem_heightallImageschema_Height_TImageHeight_31 instance.
func (me *XsdGoPkgHasElem_heightallImageschema_Height_TImageHeight_31) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_heightallImageschema_Height_TImageHeight_31; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Text that is included in the TITLE attribute of the link formed around the image in the HTML rendering.
type XsdGoPkgHasElem_descriptionallImageschema_Description_XsdtString_ struct {
	//	Text that is included in the TITLE attribute of the link formed around the image in the HTML rendering.
	Description xsdt.String `xml:"description"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_descriptionallImageschema_Description_XsdtString_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_descriptionallImageschema_Description_XsdtString_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElem_descriptionallImageschema_Description_XsdtString_ instance.
func (me *XsdGoPkgHasElem_descriptionallImageschema_Description_XsdtString_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_descriptionallImageschema_Description_XsdtString_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Describes the image, it's used in the ALT attribute of the HTML <img> tag when the channel is rendered in HTML.
type XsdGoPkgHasElem_titleallImageschema_Title_XsdtString_ struct {
	//	Describes the image, it's used in the ALT attribute of the HTML <img> tag when the channel is rendered in HTML.
	Title xsdt.String `xml:"title"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_titleallImageschema_Title_XsdtString_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_titleallImageschema_Title_XsdtString_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElem_titleallImageschema_Title_XsdtString_ instance.
func (me *XsdGoPkgHasElem_titleallImageschema_Title_XsdtString_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_titleallImageschema_Title_XsdtString_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TImage struct {
	//	The height of the image in pixels.
	XsdGoPkgHasElem_heightallImageschema_Height_TImageHeight_31

	//	Text that is included in the TITLE attribute of the link formed around the image in the HTML rendering.
	XsdGoPkgHasElem_descriptionallImageschema_Description_XsdtString_

	//	Describes the image, it's used in the ALT attribute of the HTML <img> tag when the channel is rendered in HTML.
	XsdGoPkgHasElem_titleallImageschema_Title_XsdtString_

	//	The URL of the site, when the channel is rendered, the image is a link to the site. (Note, in practice the image <title> and <link> should have the same value as the channel's <title> and <link>.
	XsdGoPkgHasElem_linkallImageschema_Link_XsdtAnyURI_

	//	The width of the image in pixels.
	XsdGoPkgHasElem_widthallImageschema_Width_TImageWidth_88

	//	The URL of the image file.
	XsdGoPkgHasElem_urlallImageschema_Url_XsdtAnyURI_
}

//	If the WalkHandlers.TImage function is not nil (ie. was set by outside code), calls it with this TImage instance as the single argument. Then calls the Walk() method on 6/6 embed(s) and 0/0 field(s) belonging to this TImage instance.
func (me *TImage) Walk() (err error) {
	if fn := WalkHandlers.TImage; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElem_titleallImageschema_Title_XsdtString_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_linkallImageschema_Link_XsdtAnyURI_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_widthallImageschema_Width_TImageWidth_88.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_urlallImageschema_Url_XsdtAnyURI_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_heightallImageschema_Height_TImageHeight_31.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_descriptionallImageschema_Description_XsdtString_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_imagechoicesequenceRssChannelschema_Image_TImage_ struct {
	//	Specifies a GIF, JPEG or PNG image that can be displayed with the channel.
	Images []*TImage `xml:"image"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_imagechoicesequenceRssChannelschema_Image_TImage_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_imagechoicesequenceRssChannelschema_Image_TImage_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_imagechoicesequenceRssChannelschema_Image_TImage_ instance.
func (me *XsdGoPkgHasElems_imagechoicesequenceRssChannelschema_Image_TImage_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_imagechoicesequenceRssChannelschema_Image_TImage_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Images {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Allows processes to register with a cloud to be notified of updates to the channel, implementing a lightweight publish-subscribe protocol for RSS feeds.
//	Specifies a web service that supports the rssCloud interface which can be implemented in HTTP-POST, XML-RPC or SOAP 1.1. Its purpose is to allow processes to register with a cloud to be notified of updates to the channel, implementing a lightweight publish-subscribe protocol for RSS feeds.
type XsdGoPkgHasAttr_RegisterProcedure_XsdtString_ struct {
	RegisterProcedure xsdt.String `xml:"registerProcedure,attr"`
}

type XsdGoPkgHasAttr_Port_XsdtPositiveInteger_ struct {
	Port xsdt.PositiveInteger `xml:"port,attr"`
}

type TCloudProtocol xsdt.String

//	Returns true if the value of this enumerated TCloudProtocol is "http-post".
func (me TCloudProtocol) IsHttpPost() bool { return me == "http-post" }

//	Returns true if the value of this enumerated TCloudProtocol is "soap".
func (me TCloudProtocol) IsSoap() bool { return me == "soap" }

//	Returns true if the value of this enumerated TCloudProtocol is "xml-rpc".
func (me TCloudProtocol) IsXmlRpc() bool { return me == "xml-rpc" }

//	Since TCloudProtocol is just a simple String type, this merely returns the current string value.
func (me TCloudProtocol) String() string { return xsdt.String(me).String() }

//	This convenience method just performs a simple type conversion to TCloudProtocol's alias type xsdt.String.
func (me TCloudProtocol) ToXsdtString() xsdt.String { return xsdt.String(me) }

//	Since TCloudProtocol is just a simple String type, this merely sets the current value from the specified string.
func (me *TCloudProtocol) Set(s string) { (*xsdt.String)(me).Set(s) }

type XsdGoPkgHasAttr_Protocol_TCloudProtocol_ struct {
	Protocol TCloudProtocol `xml:"protocol,attr"`
}

type XsdGoPkgHasAttr_Path_XsdtString_ struct {
	Path xsdt.String `xml:"path,attr"`
}

type TCloud struct {
	XsdGoPkgHasAttr_Port_XsdtPositiveInteger_

	XsdGoPkgHasAttr_Protocol_TCloudProtocol_

	XsdGoPkgHasAttr_Path_XsdtString_

	XsdGoPkgHasAttr_RegisterProcedure_XsdtString_

	XsdGoPkgHasAttr_Domain_XsdtString_
}

//	If the WalkHandlers.TCloud function is not nil (ie. was set by outside code), calls it with this TCloud instance as the single argument. Then calls the Walk() method on 0/5 embed(s) and 0/0 field(s) belonging to this TCloud instance.
func (me *TCloud) Walk() (err error) {
	if fn := WalkHandlers.TCloud; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_cloudchoicesequenceRssChannelschema_Cloud_TCloud_ struct {
	//	Allows processes to register with a cloud to be notified of updates to the channel, implementing a lightweight publish-subscribe protocol for RSS feeds.
	Clouds []*TCloud `xml:"cloud"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_cloudchoicesequenceRssChannelschema_Cloud_TCloud_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_cloudchoicesequenceRssChannelschema_Cloud_TCloud_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_cloudchoicesequenceRssChannelschema_Cloud_TCloud_ instance.
func (me *XsdGoPkgHasElems_cloudchoicesequenceRssChannelschema_Cloud_TCloud_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_cloudchoicesequenceRssChannelschema_Cloud_TCloud_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Clouds {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	The PICS rating for the channel.
type XsdGoPkgHasElems_ratingchoicesequenceRssChannelschema_Rating_XsdtString_ struct {
	//	The PICS rating for the channel.
	Ratings []xsdt.String `xml:"rating"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_ratingchoicesequenceRssChannelschema_Rating_XsdtString_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_ratingchoicesequenceRssChannelschema_Rating_XsdtString_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_ratingchoicesequenceRssChannelschema_Rating_XsdtString_ instance.
func (me *XsdGoPkgHasElems_ratingchoicesequenceRssChannelschema_Rating_XsdtString_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_ratingchoicesequenceRssChannelschema_Rating_XsdtString_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Specifies a text input box that can be displayed with the channel.
//	The purpose of this element is something of a mystery! You can use it to specify a search engine box. Or to allow a reader to provide feedback. Most aggregators ignore it.
//	The name of the text object in the text input area.
type XsdGoPkgHasElem_nameallTextInputschema_Name_XsdtString_ struct {
	//	The name of the text object in the text input area.
	Name xsdt.String `xml:"name"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_nameallTextInputschema_Name_XsdtString_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_nameallTextInputschema_Name_XsdtString_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElem_nameallTextInputschema_Name_XsdtString_ instance.
func (me *XsdGoPkgHasElem_nameallTextInputschema_Name_XsdtString_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_nameallTextInputschema_Name_XsdtString_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TextInput struct {
	//	The name of the text object in the text input area.
	XsdGoPkgHasElem_nameallTextInputschema_Name_XsdtString_

	//	The label of the Submit button in the text input area.
	XsdGoPkgHasElem_titleallImageschema_Title_XsdtString_

	//	Explains the text input area.
	XsdGoPkgHasElem_descriptionallImageschema_Description_XsdtString_

	//	The URL of the CGI script that processes text input requests.
	XsdGoPkgHasElem_linkallImageschema_Link_XsdtAnyURI_
}

//	If the WalkHandlers.TextInput function is not nil (ie. was set by outside code), calls it with this TextInput instance as the single argument. Then calls the Walk() method on 4/4 embed(s) and 0/0 field(s) belonging to this TextInput instance.
func (me *TextInput) Walk() (err error) {
	if fn := WalkHandlers.TextInput; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElem_descriptionallImageschema_Description_XsdtString_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_linkallImageschema_Link_XsdtAnyURI_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_nameallTextInputschema_Name_XsdtString_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElem_titleallImageschema_Title_XsdtString_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_textInputchoicesequenceRssChannelschema_TextInput_TextInput_ struct {
	//	Specifies a text input box that can be displayed with the channel.
	TextInputs []*TextInput `xml:"textInput"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_textInputchoicesequenceRssChannelschema_TextInput_TextInput_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_textInputchoicesequenceRssChannelschema_TextInput_TextInput_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_textInputchoicesequenceRssChannelschema_TextInput_TextInput_ instance.
func (me *XsdGoPkgHasElems_textInputchoicesequenceRssChannelschema_TextInput_TextInput_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_textInputchoicesequenceRssChannelschema_TextInput_TextInput_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.TextInputs {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

//	Email address for person responsible for editorial content.
type XsdGoPkgHasElems_managingEditorchoicesequenceRssChannelschema_ManagingEditor_TEmailAddress_ struct {
	//	Email address for person responsible for editorial content.
	ManagingEditors []TEmailAddress `xml:"managingEditor"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_managingEditorchoicesequenceRssChannelschema_ManagingEditor_TEmailAddress_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_managingEditorchoicesequenceRssChannelschema_ManagingEditor_TEmailAddress_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_managingEditorchoicesequenceRssChannelschema_ManagingEditor_TEmailAddress_ instance.
func (me *XsdGoPkgHasElems_managingEditorchoicesequenceRssChannelschema_ManagingEditor_TEmailAddress_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_managingEditorchoicesequenceRssChannelschema_ManagingEditor_TEmailAddress_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TRssChannel struct {
	//	A string indicating the program used to generate the channel.
	XsdGoPkgHasElems_generatorchoicesequenceRssChannelschema_Generator_XsdtString_

	//	A URL that points to the documentation for the format used in the RSS file. It's probably a pointer to this page. It's for people who might stumble across an RSS file on a Web server 25 years from now and wonder what it is.
	XsdGoPkgHasElems_docschoicesequenceRssChannelschema_Docs_XsdtAnyURI_

	//	A hint for aggregators telling them which hours they can skip.
	XsdGoPkgHasElems_skipHourschoicesequenceRssChannelschema_SkipHours_TSkipHoursList_

	//	Copyright notice for content in the channel.
	XsdGoPkgHasElems_copyrightchoicesequenceRssChannelschema_Copyright_XsdtString_

	//	The language the channel is written in. This allows aggregators to group all Italian language sites, for example, on a single page. A list of allowable values for this element, as provided by Netscape, is here. You may also use values defined by the W3C.
	XsdGoPkgHasElems_languagechoicesequenceRssChannelschema_Language_XsdtLanguage_

	//	The name of the channel. It's how people refer to your service. If you have an HTML website that contains the same information as your RSS file, the title of your channel should be the same as the title of your website.
	XsdGoPkgHasElems_titlechoicesequenceRssChannelschema_Title_XsdtString_

	//	The URL to the HTML website corresponding to the channel.
	XsdGoPkgHasElems_linkchoicesequenceRssChannelschema_Link_XsdtAnyURI_

	//	A hint for aggregators telling them which days they can skip.
	XsdGoPkgHasElems_skipDayschoicesequenceRssChannelschema_SkipDays_TSkipDaysList_

	//	Email address for person responsible for technical issues relating to channel.
	XsdGoPkgHasElems_webMasterchoicesequenceRssChannelschema_WebMaster_TEmailAddress_

	XsdGoPkgHasElems_itemsequenceRssChannelschema_Item_TRssItem_

	//	The last time the content of the channel changed.
	XsdGoPkgHasElems_lastBuildDatechoicesequenceRssChannelschema_LastBuildDate_TRfc822FormatDate_

	//	ttl stands for time to live. It's a number of minutes that indicates how long a channel can be cached before refreshing from the source.
	XsdGoPkgHasElems_ttlchoicesequenceRssChannelschema_Ttl_XsdtNonNegativeInteger_

	//	Specifies a GIF, JPEG or PNG image that can be displayed with the channel.
	XsdGoPkgHasElems_imagechoicesequenceRssChannelschema_Image_TImage_

	//	Specify one or more categories that the channel belongs to.
	XsdGoPkgHasElems_categorychoicesequenceRssItemschema_Category_TCategory_

	//	Allows processes to register with a cloud to be notified of updates to the channel, implementing a lightweight publish-subscribe protocol for RSS feeds.
	XsdGoPkgHasElems_cloudchoicesequenceRssChannelschema_Cloud_TCloud_

	//	The publication date for the content in the channel. All date-times in RSS conform to the Date and Time Specification of RFC 822, with the exception that the year may be expressed with two characters or four characters (four preferred).
	XsdGoPkgHasElems_pubDatechoicesequenceRssItemschema_PubDate_TRfc822FormatDate_

	//	Phrase or sentence describing the channel.
	XsdGoPkgHasElems_descriptionchoicesequenceRssItemschema_Description_XsdtString_

	//	The PICS rating for the channel.
	XsdGoPkgHasElems_ratingchoicesequenceRssChannelschema_Rating_XsdtString_

	//	Specifies a text input box that can be displayed with the channel.
	XsdGoPkgHasElems_textInputchoicesequenceRssChannelschema_TextInput_TextInput_

	//	Email address for person responsible for editorial content.
	XsdGoPkgHasElems_managingEditorchoicesequenceRssChannelschema_ManagingEditor_TEmailAddress_
}

//	If the WalkHandlers.TRssChannel function is not nil (ie. was set by outside code), calls it with this TRssChannel instance as the single argument. Then calls the Walk() method on 20/20 embed(s) and 0/0 field(s) belonging to this TRssChannel instance.
func (me *TRssChannel) Walk() (err error) {
	if fn := WalkHandlers.TRssChannel; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElems_categorychoicesequenceRssItemschema_Category_TCategory_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_cloudchoicesequenceRssChannelschema_Cloud_TCloud_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_pubDatechoicesequenceRssItemschema_PubDate_TRfc822FormatDate_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_descriptionchoicesequenceRssItemschema_Description_XsdtString_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_ratingchoicesequenceRssChannelschema_Rating_XsdtString_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_textInputchoicesequenceRssChannelschema_TextInput_TextInput_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_managingEditorchoicesequenceRssChannelschema_ManagingEditor_TEmailAddress_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_generatorchoicesequenceRssChannelschema_Generator_XsdtString_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_docschoicesequenceRssChannelschema_Docs_XsdtAnyURI_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_skipHourschoicesequenceRssChannelschema_SkipHours_TSkipHoursList_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_copyrightchoicesequenceRssChannelschema_Copyright_XsdtString_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_languagechoicesequenceRssChannelschema_Language_XsdtLanguage_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_titlechoicesequenceRssChannelschema_Title_XsdtString_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_linkchoicesequenceRssChannelschema_Link_XsdtAnyURI_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_skipDayschoicesequenceRssChannelschema_SkipDays_TSkipDaysList_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_webMasterchoicesequenceRssChannelschema_WebMaster_TEmailAddress_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_itemsequenceRssChannelschema_Item_TRssItem_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_lastBuildDatechoicesequenceRssChannelschema_LastBuildDate_TRfc822FormatDate_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_ttlchoicesequenceRssChannelschema_Ttl_XsdtNonNegativeInteger_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XsdGoPkgHasElems_imagechoicesequenceRssChannelschema_Image_TImage_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_channelsequencerssschema_Channel_TRssChannel_ struct {
	Channel *TRssChannel `xml:"channel"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_channelsequencerssschema_Channel_TRssChannel_ function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_channelsequencerssschema_Channel_TRssChannel_ instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_channelsequencerssschema_Channel_TRssChannel_ instance.
func (me *XsdGoPkgHasElem_channelsequencerssschema_Channel_TRssChannel_) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_channelsequencerssschema_Channel_TRssChannel_; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Channel.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type TxsdRss struct {
	XsdGoPkgHasAttr_Version_XsdtDecimal_20

	XsdGoPkgHasElem_channelsequencerssschema_Channel_TRssChannel_
}

//	If the WalkHandlers.TxsdRss function is not nil (ie. was set by outside code), calls it with this TxsdRss instance as the single argument. Then calls the Walk() method on 1/2 embed(s) and 0/0 field(s) belonging to this TxsdRss instance.
func (me *TxsdRss) Walk() (err error) {
	if fn := WalkHandlers.TxsdRss; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XsdGoPkgHasElem_channelsequencerssschema_Channel_TRssChannel_.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElem_Rss struct {
	Rss *TxsdRss `xml:"rss"`
}

//	If the WalkHandlers.XsdGoPkgHasElem_Rss function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElem_Rss instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XsdGoPkgHasElem_Rss instance.
func (me *XsdGoPkgHasElem_Rss) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElem_Rss; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Rss.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

type XsdGoPkgHasElems_Rss struct {
	Rsses []*TxsdRss `xml:"rss"`
}

//	If the WalkHandlers.XsdGoPkgHasElems_Rss function is not nil (ie. was set by outside code), calls it with this XsdGoPkgHasElems_Rss instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XsdGoPkgHasElems_Rss instance.
func (me *XsdGoPkgHasElems_Rss) Walk() (err error) {
	if fn := WalkHandlers.XsdGoPkgHasElems_Rss; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Rsses {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

var (
	//	Set this to false to break a Walk() immediately as soon as the first error is returned by a custom handler function.
	//	If true, Walk() proceeds and accumulates all errors in the WalkErrors slice.
	WalkContinueOnError = true
	//	Contains all errors accumulated during Walk()s. If you're using this, you need to reset this yourself as needed prior to a fresh Walk().
	WalkErrors []error
	//	Your custom error-handling function, if required.
	WalkOnError func(error)
	//	Provides 49 strong-typed hooks for your own custom handler functions to be invoked when the Walk() method is called on any instance of any (non-attribute-related) struct type defined in this package.
	//	If your custom handler does get called at all for a given struct instance, then it always gets called twice, first with the 'enter' bool argument set to true, then (after having Walk()ed all subordinate struct instances, if any) once again with it set to false.
	WalkHandlers = &XsdGoPkgWalkHandlers{}
)

//	Provides 49 strong-typed hooks for your own custom handler functions to be invoked when the Walk() method is called on any instance of any (non-attribute-related) struct type defined in this package.
//	If your custom handler does get called at all for a given struct instance, then it always gets called twice, first with the 'enter' bool argument set to true, then (after having Walk()ed all subordinate struct instances, if any) once again with it set to false.
type XsdGoPkgWalkHandlers struct {
	XsdGoPkgHasElems_pubDatechoicesequenceRssItemschema_PubDate_TRfc822FormatDate_                func(*XsdGoPkgHasElems_pubDatechoicesequenceRssItemschema_PubDate_TRfc822FormatDate_, bool) error
	TextInput                                                                                     func(*TextInput, bool) error
	XsdGoPkgHasElems_cloudchoicesequenceRssChannelschema_Cloud_TCloud_                            func(*XsdGoPkgHasElems_cloudchoicesequenceRssChannelschema_Cloud_TCloud_, bool) error
	XsdGoPkgHasElem_widthallImageschema_Width_TImageWidth_88                                      func(*XsdGoPkgHasElem_widthallImageschema_Width_TImageWidth_88, bool) error
	XsdGoPkgHasElem_channelsequencerssschema_Channel_TRssChannel_                                 func(*XsdGoPkgHasElem_channelsequencerssschema_Channel_TRssChannel_, bool) error
	XsdGoPkgHasElems_hoursequenceSkipHoursListschema_Hour_TSkipHour_                              func(*XsdGoPkgHasElems_hoursequenceSkipHoursListschema_Hour_TSkipHour_, bool) error
	XsdGoPkgHasElems_managingEditorchoicesequenceRssChannelschema_ManagingEditor_TEmailAddress_   func(*XsdGoPkgHasElems_managingEditorchoicesequenceRssChannelschema_ManagingEditor_TEmailAddress_, bool) error
	XsdGoPkgHasElems_linkchoicesequenceRssChannelschema_Link_XsdtAnyURI_                          func(*XsdGoPkgHasElems_linkchoicesequenceRssChannelschema_Link_XsdtAnyURI_, bool) error
	XsdGoPkgHasElem_Rss                                                                           func(*XsdGoPkgHasElem_Rss, bool) error
	XsdGoPkgHasElems_lastBuildDatechoicesequenceRssChannelschema_LastBuildDate_TRfc822FormatDate_ func(*XsdGoPkgHasElems_lastBuildDatechoicesequenceRssChannelschema_LastBuildDate_TRfc822FormatDate_, bool) error
	TCloud                                                                                        func(*TCloud, bool) error
	XsdGoPkgHasElems_guidchoicesequenceRssItemschema_Guid_TGuid_                                  func(*XsdGoPkgHasElems_guidchoicesequenceRssItemschema_Guid_TGuid_, bool) error
	XsdGoPkgHasElems_titlechoicesequenceRssChannelschema_Title_XsdtString_                        func(*XsdGoPkgHasElems_titlechoicesequenceRssChannelschema_Title_XsdtString_, bool) error
	XsdGoPkgHasElem_descriptionallImageschema_Description_XsdtString_                             func(*XsdGoPkgHasElem_descriptionallImageschema_Description_XsdtString_, bool) error
	XsdGoPkgHasElems_ttlchoicesequenceRssChannelschema_Ttl_XsdtNonNegativeInteger_                func(*XsdGoPkgHasElems_ttlchoicesequenceRssChannelschema_Ttl_XsdtNonNegativeInteger_, bool) error
	XsdGoPkgHasElems_webMasterchoicesequenceRssChannelschema_WebMaster_TEmailAddress_             func(*XsdGoPkgHasElems_webMasterchoicesequenceRssChannelschema_WebMaster_TEmailAddress_, bool) error
	XsdGoPkgHasElems_commentschoicesequenceRssItemschema_Comments_XsdtAnyURI_                     func(*XsdGoPkgHasElems_commentschoicesequenceRssItemschema_Comments_XsdtAnyURI_, bool) error
	XsdGoPkgHasElems_docschoicesequenceRssChannelschema_Docs_XsdtAnyURI_                          func(*XsdGoPkgHasElems_docschoicesequenceRssChannelschema_Docs_XsdtAnyURI_, bool) error
	TRssChannel                                                                                   func(*TRssChannel, bool) error
	XsdGoPkgHasElem_urlallImageschema_Url_XsdtAnyURI_                                             func(*XsdGoPkgHasElem_urlallImageschema_Url_XsdtAnyURI_, bool) error
	XsdGoPkgHasElems_sourcechoicesequenceRssItemschema_Source_TSource_                            func(*XsdGoPkgHasElems_sourcechoicesequenceRssItemschema_Source_TSource_, bool) error
	XsdGoPkgHasElems_skipDayschoicesequenceRssChannelschema_SkipDays_TSkipDaysList_               func(*XsdGoPkgHasElems_skipDayschoicesequenceRssChannelschema_SkipDays_TSkipDaysList_, bool) error
	XsdGoPkgHasElems_imagechoicesequenceRssChannelschema_Image_TImage_                            func(*XsdGoPkgHasElems_imagechoicesequenceRssChannelschema_Image_TImage_, bool) error
	TSource                                                                                       func(*TSource, bool) error
	TImage                                                                                        func(*TImage, bool) error
	XsdGoPkgHasElems_textInputchoicesequenceRssChannelschema_TextInput_TextInput_                 func(*XsdGoPkgHasElems_textInputchoicesequenceRssChannelschema_TextInput_TextInput_, bool) error
	XsdGoPkgHasElems_enclosurechoicesequenceRssItemschema_Enclosure_TEnclosure_                   func(*XsdGoPkgHasElems_enclosurechoicesequenceRssItemschema_Enclosure_TEnclosure_, bool) error
	TRssItem                                                                                      func(*TRssItem, bool) error
	TCategory                                                                                     func(*TCategory, bool) error
	XsdGoPkgHasElem_titleallImageschema_Title_XsdtString_                                         func(*XsdGoPkgHasElem_titleallImageschema_Title_XsdtString_, bool) error
	TSkipDaysList                                                                                 func(*TSkipDaysList, bool) error
	XsdGoPkgHasElems_categorychoicesequenceRssItemschema_Category_TCategory_                      func(*XsdGoPkgHasElems_categorychoicesequenceRssItemschema_Category_TCategory_, bool) error
	XsdGoPkgHasElems_languagechoicesequenceRssChannelschema_Language_XsdtLanguage_                func(*XsdGoPkgHasElems_languagechoicesequenceRssChannelschema_Language_XsdtLanguage_, bool) error
	TGuid                                                                                         func(*TGuid, bool) error
	TxsdRss                                                                                       func(*TxsdRss, bool) error
	XsdGoPkgHasElems_authorchoicesequenceRssItemschema_Author_TEmailAddress_                      func(*XsdGoPkgHasElems_authorchoicesequenceRssItemschema_Author_TEmailAddress_, bool) error
	TEnclosure                                                                                    func(*TEnclosure, bool) error
	XsdGoPkgHasElems_daysequenceSkipDaysListschema_Day_TSkipDay_                                  func(*XsdGoPkgHasElems_daysequenceSkipDaysListschema_Day_TSkipDay_, bool) error
	XsdGoPkgHasElems_ratingchoicesequenceRssChannelschema_Rating_XsdtString_                      func(*XsdGoPkgHasElems_ratingchoicesequenceRssChannelschema_Rating_XsdtString_, bool) error
	XsdGoPkgHasElems_Rss                                                                          func(*XsdGoPkgHasElems_Rss, bool) error
	XsdGoPkgHasElem_heightallImageschema_Height_TImageHeight_31                                   func(*XsdGoPkgHasElem_heightallImageschema_Height_TImageHeight_31, bool) error
	XsdGoPkgHasElems_descriptionchoicesequenceRssItemschema_Description_XsdtString_               func(*XsdGoPkgHasElems_descriptionchoicesequenceRssItemschema_Description_XsdtString_, bool) error
	XsdGoPkgHasElems_itemsequenceRssChannelschema_Item_TRssItem_                                  func(*XsdGoPkgHasElems_itemsequenceRssChannelschema_Item_TRssItem_, bool) error
	XsdGoPkgHasElem_linkallImageschema_Link_XsdtAnyURI_                                           func(*XsdGoPkgHasElem_linkallImageschema_Link_XsdtAnyURI_, bool) error
	XsdGoPkgHasElem_nameallTextInputschema_Name_XsdtString_                                       func(*XsdGoPkgHasElem_nameallTextInputschema_Name_XsdtString_, bool) error
	XsdGoPkgHasElems_skipHourschoicesequenceRssChannelschema_SkipHours_TSkipHoursList_            func(*XsdGoPkgHasElems_skipHourschoicesequenceRssChannelschema_SkipHours_TSkipHoursList_, bool) error
	TSkipHoursList                                                                                func(*TSkipHoursList, bool) error
	XsdGoPkgHasElems_generatorchoicesequenceRssChannelschema_Generator_XsdtString_                func(*XsdGoPkgHasElems_generatorchoicesequenceRssChannelschema_Generator_XsdtString_, bool) error
	XsdGoPkgHasElems_copyrightchoicesequenceRssChannelschema_Copyright_XsdtString_                func(*XsdGoPkgHasElems_copyrightchoicesequenceRssChannelschema_Copyright_XsdtString_, bool) error
}
